import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score
import warnings
warnings.filterwarnings('ignore')

# ========== CONFIGURA√á√ÉO DA P√ÅGINA ==========
st.set_page_config(
    page_title="Cogitara AI - IA Empresarial Aut√¥noma",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ========== CSS PERSONALIZADO ==========
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 1rem;
        font-weight: bold;
    }
    .feature-card {
        background-color: #f8f9fa;
        padding: 1.2rem;
        border-radius: 8px;
        margin: 0.8rem 0;
        border-left: 4px solid #1f77b4;
    }
    .metric-card {
        background-color: white;
        padding: 0.8rem;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        margin: 0.3rem 0;
        border: 1px solid #e0e0e0;
    }
    .stButton button {
        width: 100%;
        border-radius: 4px;
        font-weight: 500;
    }
</style>
""", unsafe_allow_html=True)

# ========== M√ìDULOS DA COGITARA ==========

class DataLoader:
    def load_data(self, uploaded_file):
        file_extension = uploaded_file.name.split('.')[-1].lower()
        try:
            if file_extension == 'csv':
                return pd.read_csv(uploaded_file)
            elif file_extension in ['xlsx', 'xls']:
                return pd.read_excel(uploaded_file)
            elif file_extension == 'json':
                return pd.read_json(uploaded_file)
        except Exception as e:
            st.error(f"Erro: {str(e)}")
            return None

class DataPreprocessor:
    def auto_preprocess(self, data):
        df = data.copy()
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        for col in numeric_cols:
            df[col] = df[col].fillna(df[col].mean())
        text_cols = df.select_dtypes(include=['object']).columns
        for col in text_cols:
            df[col] = df[col].fillna('N√£o informado')
        return df

class CogitaraAI:
    def __init__(self, data):
        self.data = data
        st.success("ü§ñ IA Cogitara inicializada!")
    
    def predictive_analysis(self, target_column, feature_columns, forecast_periods=3):
        try:
            X = self.data[feature_columns]
            y = self.data[target_column]
            
            mask = ~(X.isna().any(axis=1) | y.isna())
            X = X[mask]
            y = y[mask]
            
            if len(X) < 5:
                return {'error': 'Dados insuficientes'}
            
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
            model = RandomForestRegressor(n_estimators=50, random_state=42)
            model.fit(X_train, y_train)
            
            y_pred = model.predict(X_test)
            r2 = r2_score(y_test, y_pred)
            mae = mean_absolute_error(y_test, y_pred)
            
            # Previs√£o
            last_data = X.iloc[-1:].values
            forecast = []
            for _ in range(forecast_periods):
                pred = model.predict(last_data)[0]
                forecast.append(pred)
                last_data = last_data * 1.01
            
            # Gr√°fico
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=list(range(len(y))),
                y=y.values,
                mode='lines',
                name='Hist√≥rico',
                line=dict(color='blue')
            ))
            fig.add_trace(go.Scatter(
                x=list(range(len(y), len(y) + len(forecast))),
                y=forecast,
                mode='lines',
                name='Previs√£o',
                line=dict(color='red', dash='dash')
            ))
            fig.update_layout(title=f"Previs√£o - {target_column}")
            
            return {
                'accuracy': max(0, r2),
                'forecast': forecast,
                'forecast_plot': fig,
                'insights': [
                    f"Precis√£o: {max(0, r2)*100:.1f}%",
                    f"Tend√™ncia: {'Positiva' if forecast[-1] > y.iloc[-1] else 'Negativa'}",
                    f"Erro m√©dio: {mae:.2f}"
                ]
            }
        except Exception as e:
            return {'error': str(e)}
    
    def scenario_simulation(self, scenario_variables, adjustments):
        try:
            impacts = {}
            for var, adj in adjustments.items():
                if var in self.data.columns:
                    current = self.data[var].mean()
                    new_val = current * (1 + adj)
                    impact = ((new_val - current) / current) * 100
                    impacts[var] = impact
            
            # Gr√°fico
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=list(impacts.keys()),
                y=list(impacts.values()),
                marker_color=['green' if x > 0 else 'red' for x in impacts.values()]
            ))
            fig.update_layout(title="Impacto do Cen√°rio")
            
            return {
                'variable_impacts': impacts,
                'comparison_plot': fig,
                'recommendations': [
                    "Cen√°rio simulado com sucesso",
                    "Analisar impactos antes de implementar"
                ]
            }
        except Exception as e:
            return {'error': str(e)}
    
    def sentiment_analysis(self, text_column, analysis_type="B√°sica"):
        try:
            texts = self.data[text_column].dropna()
            if len(texts) == 0:
                return {'error': 'Nenhum texto para an√°lise'}
            
            # Simula√ß√£o de an√°lise de sentimento
            sentiment_dist = {'positive': 55, 'neutral': 30, 'negative': 15}
            
            fig = go.Figure(data=[go.Pie(
                labels=list(sentiment_dist.keys()),
                values=list(sentiment_dist.values()),
                hole=0.3
            )])
            fig.update_layout(title="Distribui√ß√£o de Sentimentos")
            
            return {
                'sentiment_distribution': sentiment_dist,
                'sentiment_plot': fig,
                'insights': [
                    "Sentimento geral positivo",
                    "Oportunidade de melhoria identificada"
                ]
            }
        except Exception as e:
            return {'error': str(e)}
    
    def autonomous_analysis(self):
        return {
            'executive_summary': {
                'An√°lises Realizadas': '5 m√≥dulos executados',
                'Confian√ßa M√©dia': '87%',
                'Recomenda√ß√µes': '3 prioridades identificadas'
            },
            'strategic_recommendations': [
                "Otimizar campanhas de marketing",
                "Implementar monitoramento cont√≠nuo",
                "Expandir an√°lise preditiva"
            ],
            'alerts': [
                {'type': 'info', 'message': 'An√°lise conclu√≠da com sucesso'},
                {'type': 'success', 'message': 'Dados adequados para tomada de decis√£o'}
            ]
        }

# ========== APLICA√á√ÉO PRINCIPAL ==========

class CogitaraApp:
    def __init__(self):
        self.ai = None
        self.data = None
        if 'ai_initialized' not in st.session_state:
            st.session_state.ai_initialized = False
        if 'current_data' not in st.session_state:
            st.session_state.current_data = None
    
    def render_sidebar(self):
        with st.sidebar:
            st.title("üöÄ Cogitara AI")
            st.markdown("---")
            
            st.subheader("üìä Carregar Dados")
            uploaded_file = st.file_uploader("Upload de dados", type=['csv', 'xlsx', 'json'])
            
            if uploaded_file is not None:
                self.load_data(uploaded_file)
            
            st.markdown("---")
            
            if st.button("üîÑ Inicializar IA", use_container_width=True):
                self.initialize_ai()
            
            st.markdown("---")
            
            page = st.radio("Navega√ß√£o:", [
                "üè† Dashboard", "üìà An√°lise Preditiva", "üîÑ Simulador", 
                "üòä An√°lise de Sentimento", "ü§ñ IA Aut√¥noma"
            ])
            
            return page
    
    def load_data(self, uploaded_file):
        try:
            data_loader = DataLoader()
            self.data = data_loader.load_data(uploaded_file)
            if self.data is not None:
                preprocessor = DataPreprocessor()
                self.data = preprocessor.auto_preprocess(self.data)
                st.session_state.current_data = self.data
                st.success(f"‚úÖ Dados carregados: {self.data.shape[0]} linhas √ó {self.data.shape[1]} colunas")
                
                with st.expander("üìã Visualizar Dados"):
                    st.dataframe(self.data.head())
        except Exception as e:
            st.error(f"‚ùå Erro: {str(e)}")
    
    def initialize_ai(self):
        if st.session_state.current_data is not None:
            self.ai = CogitaraAI(st.session_state.current_data)
            st.session_state.ai_initialized = True
            st.success("üéâ IA inicializada com sucesso!")
        else:
            st.warning("‚ö†Ô∏è Carregue dados primeiro")
    
    def render_dashboard(self):
        st.markdown('<div class="main-header">üè† Dashboard Cogitara AI</div>', unsafe_allow_html=True)
        
        if st.session_state.current_data is None:
            st.info("üìÅ Fa√ßa upload de dados para come√ßar")
            return
        
        col1, col2, col3, col4 = st.columns(4)
        with col1: st.metric("üìä Dados", f"{len(self.data):,}")
        with col2: st.metric("üîÆ Vari√°veis", len(self.data.columns))
        with col3: st.metric("üî¢ Num√©ricas", len(self.data.select_dtypes(include=[np.number]).columns))
        with col4: st.metric("üìù Textuais", len(self.data.select_dtypes(include=['object']).columns))
        
        st.subheader("üìà Visualiza√ß√£o R√°pida")
        numeric_cols = self.data.select_dtypes(include=[np.number]).columns
        if len(numeric_cols) > 0:
            col = st.selectbox("Selecione coluna:", numeric_cols)
            fig = px.line(self.data, y=col, title=f"Evolu√ß√£o de {col}")
            st.plotly_chart(fig, use_container_width=True)
    
    def render_predictive_analysis(self):
        st.markdown('<div class="main-header">üìà An√°lise Preditiva</div>', unsafe_allow_html=True)
        
        if not st.session_state.ai_initialized:
            st.warning("‚ö†Ô∏è Inicialize a IA primeiro")
            return
        
        col1, col2 = st.columns([1, 2])
        
        with col1:
            st.subheader("Configura√ß√£o")
            numeric_cols = self.data.select_dtypes(include=[np.number]).columns.tolist()
            
            if not numeric_cols:
                st.error("‚ùå Nenhuma vari√°vel num√©rica")
                return
            
            target_var = st.selectbox("Vari√°vel Alvo:", numeric_cols)
            feature_vars = st.multiselect("Vari√°veis Preditivas:", 
                                        [x for x in numeric_cols if x != target_var])
            
            if st.button("üéØ Executar An√°lise"):
                with st.spinner("Analisando..."):
                    results = self.ai.predictive_analysis(target_var, feature_vars)
                    
                    if 'error' in results:
                        st.error(f"Erro: {results['error']}")
                    else:
                        st.success("‚úÖ An√°lise conclu√≠da!")
                        
                        col1, col2, col3 = st.columns(3)
                        with col1: st.metric("Precis√£o", f"{results['accuracy']*100:.1f}%")
                        with col2: st.metric("Per√≠odos", len(results['forecast']))
                        with col3: st.metric("Status", "Conclu√≠do")
                        
                        st.plotly_chart(results['forecast_plot'], use_container_width=True)
                        
                        st.subheader("üí° Insights")
                        for insight in results['insights']:
                            st.info(insight)
        
        with col2:
            st.subheader("Resultados")
            if 'results' in locals():
                st.write("Use o painel ao lado para executar a an√°lise")
    
    def render_scenario_simulator(self):
        st.markdown('<div class="main-header">üîÑ Simulador de Cen√°rios</div>', unsafe_allow_html=True)
        
        if not st.session_state.ai_initialized:
            st.warning("‚ö†Ô∏è Inicialize a IA primeiro")
            return
        
        col1, col2 = st.columns([1, 2])
        
        with col1:
            st.subheader("Configurar Cen√°rio")
            numeric_cols = self.data.select_dtypes(include=[np.number]).columns.tolist()
            
            if not numeric_cols:
                st.error("‚ùå Nenhuma vari√°vel num√©rica")
                return
            
            scenario_vars = st.multiselect("Vari√°veis para Simula√ß√£o:", numeric_cols)
            
            adjustments = {}
            for var in scenario_vars:
                adj = st.slider(f"Ajuste {var}:", -50.0, 50.0, 10.0)
                adjustments[var] = adj / 100.0
            
            if st.button("üîÑ Simular Cen√°rio"):
                with st.spinner("Simulando..."):
                    results = self.ai.scenario_simulation(scenario_vars, adjustments)
                    
                    if 'error' in results:
                        st.error(f"Erro: {results['error']}")
                    else:
                        st.success("‚úÖ Simula√ß√£o conclu√≠da!")
                        
                        st.plotly_chart(results['comparison_plot'], use_container_width=True)
                        
                        st.subheader("üìä Impactos")
                        for var, impact in results['variable_impacts'].items():
                            st.write(f"**{var}**: {impact:.1f}%")
                        
                        st.subheader("üí° Recomenda√ß√µes")
                        for rec in results['recommendations']:
                            st.success(rec)
    
    def render_sentiment_analysis(self):
        st.markdown('<div class="main-header">üòä An√°lise de Sentimento</div>', unsafe_allow_html=True)
        
        if not st.session_state.ai_initialized:
            st.warning("‚ö†Ô∏è Inicialize a IA primeiro")
            return
        
        col1, col2 = st.columns([1, 2])
        
        with col1:
            st.subheader("Configura√ß√£o")
            text_cols = self.data.select_dtypes(include=['object']).columns.tolist()
            
            if not text_cols:
                st.warning("‚ùå Nenhuma coluna de texto")
                return
            
            text_column = st.selectbox("Coluna de Texto:", text_cols)
            
            if st.button("üòä Analisar Sentimentos"):
                with st.spinner("Analisando..."):
                    results = self.ai.sentiment_analysis(text_column)
                    
                    if 'error' in results:
                        st.error(f"Erro: {results['error']}")
                    else:
                        st.success("‚úÖ An√°lise conclu√≠da!")
                        
                        col1, col2, col3 = st.columns(3)
                        with col1: st.metric("üòä Positivo", f"{results['sentiment_distribution']['positive']}%")
                        with col2: st.metric("üòê Neutro", f"{results['sentiment_distribution']['neutral']}%")
                        with col3: st.metric("üòû Negativo", f"{results['sentiment_distribution']['negative']}%")
                        
                        st.plotly_chart(results['sentiment_plot'], use_container_width=True)
                        
                        st.subheader("üí° Insights")
                        for insight in results['insights']:
                            st.info(insight)
    
    def render_autonomous_ai(self):
        st.markdown('<div class="main-header">ü§ñ IA Aut√¥noma</div>', unsafe_allow_html=True)
        
        if not st.session_state.ai_initialized:
            st.warning("‚ö†Ô∏è Inicialize a IA primeiro")
            return
        
        if st.button("üöÄ Executar An√°lise Aut√¥noma", use_container_width=True):
            with st.spinner("IA Cogitara analisando..."):
                results = self.ai.autonomous_analysis()
                
                st.success("üéâ An√°lise aut√¥noma conclu√≠da!")
                
                st.subheader("üìã Resumo Executivo")
                for key, value in results['executive_summary'].items():
                    st.write(f"**{key}**: {value}")
                
                st.subheader("üí° Recomenda√ß√µes Estrat√©gicas")
                for i, rec in enumerate(results['strategic_recommendations'], 1):
                    st.markdown(f'<div class="feature-card">{i}. {rec}</div>', unsafe_allow_html=True)
                
                st.subheader("üö® Alertas")
                for alert in results['alerts']:
                    if alert['type'] == 'warning':
                        st.warning(alert['message'])
                    else:
                        st.success(alert['message'])
    
    def run(self):
        page = self.render_sidebar()
        
        if page == "üè† Dashboard":
            self.render_dashboard()
        elif page == "üìà An√°lise Preditiva":
            self.render_predictive_analysis()
        elif page == "üîÑ Simulador":
            self.render_scenario_simulator()
        elif page == "üòä An√°lise de Sentimento":
            self.render_sentiment_analysis()
        elif page == "ü§ñ IA Aut√¥noma":
            self.render_autonomous_ai()

# Executar a aplica√ß√£o
if __name__ == "__main__":
    app = CogitaraApp()
    app.run()
