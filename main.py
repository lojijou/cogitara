import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings('ignore')

from .modules.predictive_analysis import PredictiveAnalyzer
from .modules.scenario_simulator import ScenarioSimulator
from .modules.sentiment_analysis import SentimentAnalyzer
from .modules.ai_core import AICore

class CogitaraAI:
    """Classe principal da IA Cogitara - IA Empresarial Aut√¥noma"""
    
    def __init__(self, data):
        self.data = data
        self.ai_core = AICore()
        self.predictive_analyzer = PredictiveAnalyzer()
        self.scenario_simulator = ScenarioSimulator()
        self.sentiment_analyzer = SentimentAnalyzer()
        
        # Inicializa√ß√£o autom√°tica
        self._initialize_ai()
    
    def _initialize_ai(self):
        """Inicializa os componentes da IA"""
        print("üöÄ Inicializando Cogitara AI...")
        self.ai_core.learn_data_patterns(self.data)
        print("‚úÖ Cogitara AI inicializada com sucesso!")
    
    def predictive_analysis(self, target_column, feature_columns=None, forecast_periods=6):
        """Executa an√°lise preditiva"""
        return self.predictive_analyzer.analyze(
            data=self.data,
            target_column=target_column,
            feature_columns=feature_columns,
            forecast_periods=forecast_periods,
            ai_core=self.ai_core
        )
    
    def scenario_simulation(self, scenario_variables, adjustments):
        """Executa simula√ß√£o de cen√°rios"""
        return self.scenario_simulator.simulate(
            data=self.data,
            scenario_variables=scenario_variables,
            adjustments=adjustments,
            ai_core=self.ai_core
        )
    
    def sentiment_analysis(self, text_column, analysis_type="An√°lise B√°sica"):
        """Executa an√°lise de sentimento"""
        return self.sentiment_analyzer.analyze(
            data=self.data,
            text_column=text_column,
            analysis_type=analysis_type,
            ai_core=self.ai_core
        )
    
    def quick_sentiment_analysis(self, text_column):
        """An√°lise r√°pida de sentimento"""
        return self.sentiment_analyzer.quick_analyze(
            data=self.data,
            text_column=text_column
        )
    
    def autonomous_analysis(self):
        """Executa an√°lise aut√¥noma completa"""
        print("ü§ñ Iniciando an√°lise aut√¥noma...")
        
        results = {
            'executive_summary': self._generate_executive_summary(),
            'strategic_recommendations': self._generate_strategic_recommendations(),
            'alerts': self._generate_alerts(),
            'key_insights': self._generate_key_insights()
        }
        
        return results
    
    def _generate_executive_summary(self):
        """Gera resumo executivo autom√°tico"""
        summary = {}
        
        # An√°lise b√°sica dos dados
        numeric_data = self.data.select_dtypes(include=[np.number])
        
        if not numeric_data.empty:
            summary['Total de Registros'] = f"{len(self.data):,}"
            summary['Vari√°veis Num√©ricas'] = f"{len(numeric_data.columns)}"
            summary['Per√≠odo de Dados'] = "Personalizado"  # Poderia detectar automaticamente
            
            # M√©tricas principais
            for col in numeric_data.columns[:3]:  # Primeiras 3 colunas num√©ricas
                mean_val = numeric_data[col].mean()
                summary[f'M√©dia de {col}'] = f"{mean_val:,.2f}"
        
        return summary
    
    def _generate_strategic_recommendations(self):
        """Gera recomenda√ß√µes estrat√©gicas autom√°ticas"""
        recommendations = []
        
        # An√°lise de dados num√©ricos
        numeric_data = self.data.select_dtypes(include=[np.number])
        
        if not numeric_data.empty:
            # Recomenda√ß√µes baseadas em variabilidade
            for col in numeric_data.columns:
                variability = numeric_data[col].std() / numeric_data[col].mean()
                if variability > 0.5:
                    recommendations.append(
                        f"Alta variabilidade em {col}. Considere investigar causas e oportunidades de estabiliza√ß√£o."
                    )
            
            # Recomenda√ß√µes baseadas em correla√ß√µes
            if len(numeric_data.columns) >= 2:
                corr_matrix = numeric_data.corr()
                high_corr_pairs = []
                
                for i in range(len(corr_matrix.columns)):
                    for j in range(i+1, len(corr_matrix.columns)):
                        if abs(corr_matrix.iloc[i, j]) > 0.7:
                            high_corr_pairs.append(
                                (corr_matrix.columns[i], corr_matrix.columns[j], corr_matrix.iloc[i, j])
                            )
                
                for var1, var2, corr in high_corr_pairs[:2]:
                    recommendations.append(
                        f"Forte correla√ß√£o ({corr:.2f}) entre {var1} e {var2}. Pode indicar rela√ß√£o causal importante."
                    )
        
        # Recomenda√ß√µes padr√£o
        default_recommendations = [
            "Implementar monitoramento cont√≠nuo das m√©tricas-chave identificadas",
            "Desenvolver dashboard executivo para acompanhamento em tempo real",
            "Criar sistema de alertas para anomalias nos dados",
            "Expandir an√°lise para incluir dados externos do mercado"
        ]
        
        recommendations.extend(default_recommendations)
        return recommendations[:6]  # Limitar a 6 recomenda√ß√µes
    
    def _generate_alerts(self):
        """Gera alertas autom√°ticos"""
        alerts = []
        
        numeric_data = self.data.select_dtypes(include=[np.number])
        
        if not numeric_data.empty:
            # Alertas baseados em outliers
            for col in numeric_data.columns:
                Q1 = numeric_data[col].quantile(0.25)
                Q3 = numeric_data[col].quantile(0.75)
                IQR = Q3 - Q1
                outliers = numeric_data[
                    (numeric_data[col] < (Q1 - 1.5 * IQR)) | 
                    (numeric_data[col] > (Q3 + 1.5 * IQR))
                ]
                
                if len(outliers) > 0:
                    alerts.append({
                        'type': 'warning',
                        'message': f"Poss√≠veis outliers detectados em {col} ({len(outliers)} ocorr√™ncias)"
                    })
            
            # Alertas baseados em tend√™ncias
            for col in numeric_data.columns:
                if len(numeric_data) > 5:
                    recent_trend = numeric_data[col].tail(3).mean()
                    historical_trend = numeric_data[col].head(3).mean()
                    
                    if recent_trend > historical_trend * 1.2:
                        alerts.append({
                            'type': 'opportunity',
                            'message': f"Tend√™ncia positiva forte em {col}. Considerar expans√£o."
                        })
        
        return alerts
    
    def _generate_key_insights(self):
        """Gera insights chave dos dados"""
        insights = []
        
        numeric_data = self.data.select_dtypes(include=[np.number])
        
        if not numeric_data.empty:
            # Insights de distribui√ß√£o
            for col in numeric_data.columns:
                skewness = numeric_data[col].skew()
                if abs(skewness) > 1:
                    insights.append(
                        f"Distribui√ß√£o assim√©trica em {col} (skewness: {skewness:.2f})"
                    )
        
        return insights